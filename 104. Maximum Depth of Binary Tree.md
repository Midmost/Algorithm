# Question: 104. Maximum Depth of Binary Tree
#### 2021/01/11


## Problem-solving steps
* 문제 해석:
* 알고리즘: 
* 자료구조: 
* 문제 해결 과정: 
        #####일반화: 가장 긴 길이를 가진 노드의 개수를 반환하여라   
        -> 개수를 알고 싶어 -> 마지막 애 입장에서는 항상 길이는 하나밖에 없지 않나...?    
        -> 다음 노드로 갔다? 카운트 증가로 해보자  
        -> 근데 노드가 binary 양쪽으로 증가하니까 둘을 비교해서 큰 쪽의 카운트 수를 리턴해야겠다.    
        
        #####점화식: f(root[]) = 가장 큰 노드의 갯수
            
        #####base: root가 0이면...당연히 0이 반환되기는 하지...이걸 생각...못했네...  
        #####general: f(root) = count(현재 root 위치 + f(root))  



---
틀린답
```python3
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        res_lft = 0
        res_rgt = 0
        
        def f(res_lft, res_rgt, root):
            #base
            if root is None:
                return 0
        
            #general
            f(res_lft, res_rgt, root.left)
            res_lft = res_lft + 1
            
            f(res_lft, res_rgt, root.right)
            res_rgt = res_rgt + 1
            
            if res_lft >= res_rgt:
                return res_lft
            else:
                return res_rgt
            
        f(res_lft, res_rgt, root)    
        return f(res_lft, res_rgt, root)

```
